from telegram import Update
from telegram.ext import Application, CommandHandler, ContextTypes
import aiohttp
from datetime import datetime
import logging

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = "8057615426:AAFgreOl9Ton5QmgrqpBBfAk428uJHyPUUI"
CBR_API_URL = "https://www.cbr-xml-daily.ru/daily_json.js"


async def get_cbr_rates():
    """–ü–æ–ª—É—á–∞–µ–º –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç –æ—Ç –¶–ë –†–§"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(CBR_API_URL, timeout=10) as response:
                response.raise_for_status()
                import json
                text = await response.text()
                return json.loads(text)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ API: {e}")
        return None


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    await update.message.reply_text(
        "üè¶ –ë–æ—Ç –∫—É—Ä—Å–æ–≤ –≤–∞–ª—é—Ç –¶–ë –†–§\n\n"
        "–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        "/rates - –æ—Å–Ω–æ–≤–Ω—ã–µ –∫—É—Ä—Å—ã\n"
        "/fullrates - –≤—Å–µ –≤–∞–ª—é—Ç—ã\n"
        "/convert <—Å—É–º–º–∞> <–≤–∞–ª—é—Ç–∞>\n"
        "/convert <—Å—É–º–º–∞> <–≤–∞–ª—é—Ç–∞1> to <–≤–∞–ª—é—Ç–∞2>"
    )


async def rates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Å–Ω–æ–≤–Ω—ã–µ –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç"""
    data = await get_cbr_rates()
    if not data:
        await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö")
        return

    popular = ['USD', 'EUR', 'GBP', 'CNY', 'JPY', 'TRY', 'KZT']
    date = datetime.fromisoformat(data['Date'].replace('Z', '+00:00')).strftime("%d.%m.%Y")
    message = f"üìä –û—Å–Ω–æ–≤–Ω—ã–µ –∫—É—Ä—Å—ã ({date})\n\n"

    for code in popular:
        if code in data['Valute']:
            curr = data['Valute'][code]
            message += f"{curr['CharCode']}: {curr['Value']:.2f} ‚ÇΩ –∑–∞ {curr['Nominal']} {curr['Name']}\n"

    await update.message.reply_text(message)


async def fullrates(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –≤–∞–ª—é—Ç—ã"""
    data = await get_cbr_rates()
    if not data:
        await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö")
        return

    date = datetime.fromisoformat(data['Date'].replace('Z', '+00:00')).strftime("%d.%m.%Y")
    message = f"üìã –í—Å–µ –≤–∞–ª—é—Ç—ã –¶–ë –†–§ ({date})\n\n"
    sorted_currencies = sorted(data['Valute'].items(), key=lambda x: x[1]['CharCode'])

    temp_message = ""
    for code, currency in sorted_currencies:
        line = (
            f"{currency['CharCode']} ({currency['Name']}):\n"
            f"  {currency['Nominal']} {currency['CharCode']} = {currency['Value']:.2f} ‚ÇΩ\n"
            f"  üîÑ –ü—Ä–µ–¥—ã–¥—É—â–∏–π –∫—É—Ä—Å: {currency['Previous']:.2f} ‚ÇΩ\n\n"
        )
        if len(temp_message + line) > 4096:
            await update.message.reply_text(temp_message)
            temp_message = line
        else:
            temp_message += line
    if temp_message:
        await update.message.reply_text(temp_message)


async def convert(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤–∞–ª—é—Ç"""
    data = await get_cbr_rates()
    if not data:
        await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö")
        return

    args = context.args
    if len(args) < 2:
        await update.message.reply_text("‚öôÔ∏è –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:\n/convert 100 USD\n/convert 100 USD to EUR")
        return

    try:
        amount = float(args[0])
        from_currency = args[1].upper()
        to_currency = "RUB"  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ —Ä—É–±–ª–∏
        if len(args) >= 4 and args[2].lower() == "to":
            to_currency = args[3].upper()

        valutes = data['Valute']

        if from_currency == "RUB":
            amount_in_rub = amount
        elif from_currency in valutes:
            amount_in_rub = amount * valutes[from_currency]['Value'] / valutes[from_currency]['Nominal']
        else:
            await update.message.reply_text(f"‚ùå –í–∞–ª—é—Ç–∞ {from_currency} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return

        if to_currency == "RUB":
            result = amount_in_rub
        elif to_currency in valutes:
            result = amount_in_rub / (valutes[to_currency]['Value'] / valutes[to_currency]['Nominal'])
        else:
            await update.message.reply_text(f"‚ùå –í–∞–ª—é—Ç–∞ {to_currency} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return

        await update.message.reply_text(
            f"üí± {amount} {from_currency} = {result:.2f} {to_currency}"
        )

    except ValueError:
        await update.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–∏–º–µ—Ä: /convert 100 USD to EUR")


def main():
    application = Application.builder().token(TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("rates", rates))
    application.add_handler(CommandHandler("fullrates", fullrates))
    application.add_handler(CommandHandler("convert", convert))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    application.run_polling()


if __name__ == "__main__":
    main()
